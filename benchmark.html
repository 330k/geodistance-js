<!DOCTYPE html>
<html lang="ja">
<head>
<title>Geodesic Distance Formulae Benchmark</title>
<meta charset="utf-8"/>
</head>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
"use strict";
const TIME_N = 5; // number of times for benchmark repeat
let ERR_BIN_START =  0;
let ERR_BIN_END   =  0;
const worker = new Worker("benchmark_worker.js");
const result = {};
let testdata = [];
let flag_graph_complete = false;

{
  worker.onmessage = function(e){
    document.getElementById("btn_benchmark").disabled = false;
    document.getElementById("message").innerHTML = "";
    ERR_BIN_START = Math.floor(Math.log10(e.data.distance_min));
    ERR_BIN_END = Math.floor(Math.log10(e.data.distance_max));
    testdata = e.data.testdata;
  };
  worker.postMessage({func: "loadTestData", args: []});
}

// analyse error distribution
function analyseError(dist){
  let error_abs = new Array(ERR_BIN_END - ERR_BIN_START + 1);
  let error_rel = new Array(ERR_BIN_END - ERR_BIN_START + 1);
  
  for(let i = 0; i < testdata.length; i++){
    let err1 = Math.abs(dist[i] - testdata[i][6]);
    let err2 = err1 / testdata[i][6];
    let idx = Math.floor(Math.log10(testdata[i][6])) - ERR_BIN_START;
    
    if(!error_abs[idx]) error_abs[idx] = -1;
    if(!error_rel[idx]) error_rel[idx] = -1;
    if(err1 > error_abs[idx]) error_abs[idx] = err1;
    if(err2 > error_rel[idx]) error_rel[idx] = err2;
  }
  
  return {
    error_abs,
    error_rel
  }
}

function benchmarkFunction(func_name){
  return new Promise((resolve, reject) => {
    worker.onmessage = function(e){
      resolve(e.data);
    };
    worker.postMessage({
      func: "benchmarkFunction",
      args: [func_name]
    });
  });
}

async function startBenchmark(){
  const funcs = [
    "geographiclib",
    "haversine", 
    "gsidistance", 
    "hubeny", /*"hubeny1", "hubeny2", "hubeny3", */"hubeny4", 
    "vincenty", 
    "lambert", "andoyerlambert", "andoyerlambertthomas"
  ];
  
  document.getElementById("btn_benchmark").disabled = true;
  document.getElementById("message").innerHTML = "executing benchmarks...";
  
  for(const f of funcs){
    result[f] = result[f] || {
      times: [],
      dist: null,
      errors: {}
    };
  }
  
  for(let i = 0; i < TIME_N; i++){
    for(const f of funcs){
      const r = await benchmarkFunction(f);
      result[f].times.push(r.time);
      result[f].dist = r.dist;
    }
  }
  
  for(const f of funcs){
    result[f].errors = analyseError(result[f].dist);
  }
  
  showResultTable(result);

  document.getElementById("message").innerHTML = "drawing graphs...";
  
  setTimeout(() => {
    showResultGraph(result);
    document.getElementById("message").innerHTML = "";
    document.getElementById("btn_benchmark").disabled = false;
  }, 0);
}

function showResultTable(result){
  const buf = []
  let N = null;
  
  buf.push("<table>");
  buf.push("<table><tr><th>name</th><th>average time [ms]</th>");
  for(let i = ERR_BIN_START; i <= ERR_BIN_END; i++){
    if(i <= 0){
      buf.push(`<th>${Math.pow(10,i).toPrecision(1)}m-</th>`);
    }else{
      buf.push(`<th>${Math.pow(10,i)}m-</th>`);
    }
  }
  buf.push("</tr>");
  
  for(const f in result){
    buf.push("<tr><td class='center'>" + f + "</td>");
    buf.push("<td class='right'>" + (result[f].times.reduce((i,a)=>i+a) / result[f].times.length).toFixed(1) + "</td>");
    for(let i = 0; i <= ERR_BIN_END - ERR_BIN_START; i++){
      if(result[f].errors.error_rel[i]){
        buf.push("<td>" + result[f].errors.error_rel[i].toExponential(3) + "</td>");
      }else{
        buf.push("<td></td>");
      }
    }
    buf.push("</tr>");
    
    N = N || result[f].times.length;
  }
  
  buf.push("</table>");
  buf.unshift(`<p>Calculation Time (N=${N}) and Relative Error</p>`);
  
  document.getElementById("result").innerHTML = buf.join("");
}

function showResultGraph(result){
  const labels = [];
  const datasets = [];
  const colors = ["#3f3d99", "#993d70", "#998b3d", "#3d9955", "#3d5a99", "#993d8f", "#996c3d", "#43993d", "#3d7899", "#833d99", "#994e3d", "#61993d"];
  const shapes = ["rect", "triangle", "rectRot"];
  
  if(flag_graph_complete){
    return;
  }
  
  for(let i = ERR_BIN_START; i <= ERR_BIN_END; i++){
    if(i <= 0){
      labels.push(Math.pow(10,i));
    }else{
      labels.push(Math.pow(10,i));
    }
  }
  let j = 0;
  
  for(const f in result){
    const dataset = {};
    
    dataset.label = f;
    dataset.backgroundColor = colors[j % colors.length];
    dataset.pointStyle = shapes[Math.floor(j / 4) % shapes.length];
    dataset.borderColor = dataset.backgroundColor;
    dataset.data = [];
    for(let i = 0; i < testdata.length; i++){
      dataset.data.push([
        testdata[i][6],
        (result[f].dist[i] / testdata[i][6]) - 1
      ]);
    }
    
    j++;
    datasets.push(dataset);
  }
  
  const chart = new Chart(document.getElementById("chart"), {
    type: "scatter",
    data: {
      labels: labels,
      datasets: datasets
    },
    options: {
      plugins: {
        tooltip: {
          enabled: false
        },
        legend: {
          labels: {
            usePointStyle: true
          }
        }
      },
      scales: {
        x: {
          display: true,
          type: "logarithmic",
          title: {
            display: true,
            text: "True Distance [m]"
          }
        },
        y: {
          display: true,
          type: "logarithmic",
          title: {
            display: true,
            text: "Relative Error"
          },
          min: 1e-16,
          max: 1e1,
          ticks: {
            callback: (val, index) => {
              if(val.toExponential(1).startsWith("1")){
                return val.toExponential(1);
              }else{
                return "";
              }
            }
          }
        }
      }
    }
  });
  
  flag_graph_complete = true;
}
</script>
<style>
table {
  border-collapse: collapse;
}
th, td {
  padding: 2px;
  border: 1px solid gray;
}
.left{
  text-align: left;
}
.center{
  text-align: center;
}
.right{
  text-align: right;
}
</style>
<body>
<h1>Geodesic Distance Calculation Formulae Benchmark in JavaScript</h1>
<p>
Compare calculation speed and precision for geodesic ellipsoid distance calculation functions implemented in JavaScript.
</p>
<div>
Compared Formulae:
<ul>
<li>GeographicLib: the most accurate calculation library. <a href="https://geographiclib.sourceforge.io/">GeographicLib</a>
<li>Haversine: <a href="https://en.wikipedia.org/wiki/Great-circle_distance">Great-circle distance - Wikipedia</a>
<li>GSI: Used by GSI(Geospatial Information Authority of Japan) distance calculation service, based on Bowring's method, <a href="https://vldb.gsi.go.jp/sokuchi/surveycalc/surveycalc/algorithm/bl2st/bl2st.htm">距離と方位角の計算　計算式</a>
<li>Hubeny:  Simplified version of hubeny's formula, <a href="https://www.koeki-prj.org/~yuuji/2017/gd2/06/distances.html">Calculating Distance between Two Points - #7 Game Design 2017</a>
<li>Hubeny4: Full version of hubeny's formula, <a href="https://amano-tec.com/apps/paceruler.html">歩測計 Pace Ruler - ASTI アマノ技研</a>
<li>Vincenty: <a href="https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines">Geographical distance - Wikipedia</a>
<li>Lambert: <a href="https://dl.ndl.go.jp/info:ndljp/pid/11000306">回転楕円体上の測地線及び航程線の算出について - 国立国会図書館デジタルコレクション</a>
<li>Andoyer-Lambert: <a href="https://web.archive.org/web/20160411010136/http://www2.nc-toyama.ac.jp/~mkawai/lecture/sailing/geodetic/geosail.html">測地線航海算法(Geodesic Sailing)</a>
<li>Andoyer-Lambert-Thomas: <a href="https://metacpan.org/pod/GIS::Distance::ALT">GIS::Distance::ALT - Andoyer-Lambert-Thomas distance calculations. - metacpan.org</a>
</ul>
</div>
<div>
<button id="btn_benchmark" onclick="startBenchmark()" disabled>Start Benchmark</button> <span id="message">loading...</span>
<div id="result"></div>
<div><canvas id="chart"></canvas></div>
</div>
</body>
</html>
